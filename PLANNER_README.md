# Path Planning

The system uses two seperate path planners, a local planner and a global planner. As a global path planner, it uses RRT Connect and as a local path planner it uses the usual RRT. You can find the codes for those tasks under svea_starter/src/svea_core/src/svea/planner. Other scripts that they depend on are utils.py and smoothing.py, which you can find in the same dictionary. The script utils.py, provide the path planners the position of the obstacles and if a collision will occur or not when following the genereated path. The script smoothing.py, smoothes the path that is genereted from the path planner. 

## Global Planner - RRT Connect

## Local Planner - RRT

A RRT grows a tree rooted at the starting configuration by using random samples from the search space. The path is planned by building a tree starting from the initial position. As each sample is drawn, a connection is attempted between it and the nearest state in the tree. If the connection is feasible (passes entirely through free space and obeys any constraints), it results in the addition of the new state to the tree. When a point in the space is randomly sampled, it is checked if the point collides with an obstacle in the space. If the sampled point has no collisions, it is then checked if the straight line path between the sampled point and the nearest existing point in the tree has any collisions. If this straight line path has no collisions, the sampled point is added to the tree with the nearest point as its parent node. If there is a collision, this point is thrown out. Each time after a node is added to the tree and the node is less than some threshold distance from the goal position, it is checked if the goal can be reach in a straight line path from the added node. If the goal position is reachable, the goal position is added to the tree with the recently added node as its parent. At this point, the path planning is complete. If the goal position is still unreachable, additional points are sampled. The RRT works according to the following pseudo code:

Algorithm RRT:

```bash
Input: Initial configuration xinit, number of vertices in RRT K, incremental distance dt, Xfree is free space)
Output: RRT graph G

Function: RRT (K, xinit, dt)
  1. G.init(xinit)
  2. For i=0 to K do
  3. xrand <- random_config(Xfree)
  4. Extend(G,xrand)
  5. End for
  6. Return G

Function: Extend (G, xrand)
  1. xnear <- nearest_neighbor(G,xrand)
  2. xnew <- new_state(xnear, dt)
  3. if collision_free_path(xnear,xnew) then
  4. G.add_node(xnew)
  5. G.add_edge(xnear,xnew)
  6. End if
  7. Return G
```


## Modifications

When the path planning is done, it doesn't mean that one can use the path generated by the RRT. There are several modifications which should be done in order to make the generated path fulfill 3 fundamental criteria: Time effeciency, smoothness and collision free path. 

### Sampling Domain

### Obstacle Avoidance

### Smoothing




